---
layout: post
title:  "Integration of Backend and Frontend"
summary: "CRUD and Search Operatino for NodeJS Hosting"
author: covidvmgroup
date: '2023-03-19 17:58:45 -0500'
category: ['NojeJS']
thumbnail: /assets/img/authors/covidvm.png
keywords: NodeJS, Backend, Frontend, CRUD
permalink: /blog/CRUD-Search
usemathjax: true
---

# Midterm Demo

## Objectives

1. Insert new records (rows) to the database and reflect the change on the frontend interface (3%):
   1.  0% if no interface for this operation is present
   2. +0.5% for having the code connecting the interface with the database
   3. \+ 1.5% for having the interface for insertion
   4. +1% for successfully inserting into the database and showing the insert via an interface
2. Search the database using a keyword search. Your application should allow the user to input their search keyword and return the result to the interface (5%):
   1. 0% if no interface for this operation is present
   2. +0.5% for having the code connecting the interface with the database
   3. +1.5 % for having a textbox for entering the search keyword
   4. +3% for the successful execution of the query and the returning the result to the interface
3. Update records on the database and reflect the change on the frontend interface (3%):
   1. 0% if no interface for this operation is present
   2. +0.5% for having the code connecting the interface with the database
   3. \+ 1% for having the interface for update
   4. +1.5% for successfully updating the database and showing the update via an interface
4. Delete rows from the database (3%):
   1. 0% if no interface for this operation is present
   2. +0.5% for having the code connecting the interface with the database
   3. \+ 1% for having the interface for deletion
   4. +1.5% for successfully deleting row(s) from the database and showing the removal via an interface
5. Integrate into your application both of the advanced SQL queries you developed in stage 3. (6%):
   1. 0% if no interface for this operation is present
   2. +0.5% for having the code connecting the interface with the database
   3. \+ 4% for having the interface for the advanced queries
   4. +1.5% for successfully executing the advanced queries and showing the results via an interface

---

## Insertion 

* User insertion after registration
* User Search History (content, filter)

## Search + Integration (2. + 5.)
* Paper Search
   * using filter check box
   * return top related results
* 2 Advanced Query : Search on Map
   * Currently implemented as buttons
   * Later implemented as map components
## Update 
   * Registration Password update
   * Paper Statistics (Data generated by user search)
     * Most searched topics (top 10)
     * Most searched journals (top 10)
     * Most searched authors  (top 10)

## Delete

* Cache clean (History)

---

## Workflow

### Search Box (Front end and Backend)

Without associating with particular user name

* Front end :
  * Draw a search box (clickable, able to post to server)

* Back end :
  * get the post from client, conduct a search in database.
  * Return the searched value to user.


* Front end :
  * Get the return value from server, display it on screen.

| Search Box         | blank | blank          | blank          | blank          | blank          |
| ------------------ | ----- | -------------- | -------------- | -------------- | -------------- |
| Display Format Bar | Col1  | Col4(Optional) | Col5(Optional) | Col2(Optional) | Col3(Optional) |
| Filters            | Col1  | Col2           | Col3           | Col4           | Col5           |
| Deliminator        | ,     | ;              | :              | -              | '              |

Col_x can be : journal name, author, date start, date end, ...

When user click on any of filters, corresponding column name can be displayed in Display Format Bar to give user a feed back of what type of input they're about to give us.

Deliminators are a set of option buttons. The logic is only one button can be pressed and highlighted (meaning chosen). It handles the situation where, like when the author's name is separated by comma, then you don't have comma to be your Deliminators.



* Then you need to handle the update by updating the statistics and displaying it to user.





Now associate this process with user name

A request from client side will contain a `body` part and a `header` part. Token and username should be included in the `header` part. This enables us to associate username with query. And we can display the content when we're in dashboard. 

* Store the username in local storage in browser.

* Along with token, we send the header to server, and server insert the query item to database.

* Display the stuff when dashboard is loaded. (make a get request when load /dashboard)


---

## Future Work

### Optimization on Search 

Currently we have checkboxes for filters, and we restrict users to follow certain rules to parse their inputs. However, like google and any other search engine. Search box enumerate all possibilities of intentions of users and get the most relavent result. This should be done when we have time.